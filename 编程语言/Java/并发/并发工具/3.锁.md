## 1.Lock接口

### 1.1简介、地位、作用

◆锁是一种工具，用于控制对共享资源的访问。

◆Lock和 synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同

◆Lock并不是用来代替 synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的

◆Lock接口最常见的实现类是 Reentrantlock

◆通常情况下，Lock只允许—个线程来访问这个共享资源。不过有的时候，一些特殊的实现也可允许并发访问，比如ReadWritelock里面的 Readlock。

### 1.2为什么 synchronzed不够用？为什么需要Lock？

1）效率低:锁的释放情况少、试图获得锁时不能没定超时、不能中断一个正在试图获得锁的线程

2）不够灵活（读写锁更灵活）:加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的

3）无法知道是否成功获取到锁

### 1.3方法介绍

在Lock中声明了四个方法来获取锁

-  `lock()`

  ◆lock就是最普通的获取锁。如果锁已被其他线程获取，则进行等待

  ◆Lock不会像 synchronized-样在异常时自动释放锁

  ◆因此最佳实践是，在 finally中释放锁，以保证发生异常时锁一定被释放

  ◆lock()方法不能被中断，这会带来很大的隐患:一旦陷入死锁lock()就会陷入永久等待

  代码：

  ```java
  private static Lock lock = new ReentrantLock();
  public static void main(String[] args) {
      lock.lock();
      try {
          //业务代码
      } finally {
          lock.unlock();
      }
  }
  ```
  
- `tryLock():` 尝试获得锁，如果锁空闲就能够获得，否则直接返回FALSE

  ```java
  /**
   * Acquires the lock only if it is free at the time of invocation.
   *
   * <p>Acquires the lock if it is available and returns immediately
   * with the value {@code true}.
   * If the lock is not available then this method will return
   * immediately with the value {@code false}.
   *
   * <p>A typical usage idiom for this method would be:
   * <pre> {@code
   * Lock lock = ...;
   * if (lock.tryLock()) {
   *   try {
   *     // manipulate protected state
   *   } finally {
   *     lock.unlock();
   *   }
   * } else {
   *   // perform alternative actions
   * }}</pre>
   *
   * This usage ensures that the lock is unlocked if it was acquired, and
   * doesn't try to unlock if the lock was not acquired.
   *
   * @return {@code true} if the lock was acquired and
   *         {@code false} otherwise
   */
  boolean tryLock();
  ```

-  `tryLock( long time，TimeUnit unit）`:超时就放弃。

  ```java
  public class TryLockDeadLock implements Runnable{
  
      int flag = 1;
      static Lock lock1 = new ReentrantLock();
      static Lock lock2 = new ReentrantLock();
  
      @Override
      public void run() {
          for (int i = 0; i < 1000; i++) {
              if (flag == 1) {
                  try {
                      if (lock1.tryLock(800, TimeUnit.MILLISECONDS)) {
                          try {
                              System.out.println("线程" + Thread.currentThread().getName()+"获取到了锁1");
                              TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));
                              if (lock2.tryLock(800, TimeUnit.MILLISECONDS)) {
                                  try {
                                      System.out.println("线程" + Thread.currentThread().getName()+"获取到了锁2");
                                      System.out.println("线程" + Thread.currentThread().getName()+"获取到了锁12了");
                                  }finally {
                                      lock2.unlock();
                                  }
                              } else {
                                  System.out.println("线程" + Thread.currentThread().getName()+"获取锁2失败，已经重试");
                              }
                          } finally {
                              lock1.unlock();
                              TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));
                          }
                      } else {
                          System.out.println("线程" + Thread.currentThread().getName()+"获取锁1失败，已经重试");
                      }
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              } else {
                  try {
                      if (lock2.tryLock(500, TimeUnit.MILLISECONDS)) {
                          try {
                              System.out.println("线程" + Thread.currentThread().getName()+"获取到了锁2");
                              TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));
                              if (lock1.tryLock(500, TimeUnit.MILLISECONDS)) {
                                  try {
                                      System.out.println("线程" + Thread.currentThread().getName()+"获取到了锁1");
                                      System.out.println("线程" + Thread.currentThread().getName()+"获取到了锁21了");
                                  }finally {
                                      lock1.unlock();
                                  }
                              } else {
                                  System.out.println("线程" + Thread.currentThread().getName()+"获取锁1失败，已经重试");
                              }
                          } finally {
                              lock2.unlock();
                              TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));
                          }
                      } else {
                          System.out.println("线程" + Thread.currentThread().getName()+"获取锁2失败，已经重试");
                      }
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  
      public static void main(String[] args) {
          TryLockDeadLock tryLockDeadLock1 = new TryLockDeadLock();
          TryLockDeadLock tryLockDeadLock2 = new TryLockDeadLock();
          tryLockDeadLock1.flag = 1;
          tryLockDeadLock2.flag = 0;
          new Thread(tryLockDeadLock1).start();
          new Thread(tryLockDeadLock2).start();
      }
  }
  ```

- `lockinterruptibly():` 相当于 `tryLock(long time， TimeUnit unit)`把超时时间设置为无限。在等待锁的过程中，线程可以被中断。

  ```java
  public class LockInterruptibly implements Runnable{
  
      private Lock lock = new ReentrantLock();
      @Override
      public void run() {
          System.out.println(Thread.currentThread().getName() + "尝试获取锁");
          try {
              lock.lockInterruptibly();
              try {
                  System.out.println(Thread.currentThread().getName() + "拿到了锁");
                  TimeUnit.SECONDS.sleep(5);
              } catch (InterruptedException e) {
                  System.out.println(Thread.currentThread().getName() + "睡眠期间被中断");
              }finally {
                  lock.unlock();
                  System.out.println(Thread.currentThread().getName() + "释放了锁");
              }
          } catch (InterruptedException e) {
              System.out.println(Thread.currentThread().getName() + "获得锁期间被中断");
          }
      }
  
      public static void main(String[] args) throws InterruptedException {
          LockInterruptibly lockInterruptibly = new LockInterruptibly();
          Thread thread1 = new Thread(lockInterruptibly);
          Thread thread2 = new Thread(lockInterruptibly);
          thread1.start();
          thread2.start();
          TimeUnit.SECONDS.sleep(2);
  //        thread1.interrupt();
          thread2.interrupt();
      }
  }
  ```

- `unlock():` 释放锁,在使用的时候先`try{}finally{lock.unlock();}`确保释放锁

### 1.4可见性保证

## 2.锁的分类

> 线性要不要锁住同步资源
> 	锁住
> 		悲观锁
> 	不锁住
> 		乐观锁
>
> 多线程能否共享一把锁
> 	可以
> 		共享锁
> 	不可以
> 		独占锁
>
> 多线程竞争时，是否排队
> 	排队
> 		公平锁
> 	先尝试插队，插队失败再排队
> 		非公平锁
>
> 同一个线程是否可以重复获取同一把锁
> 	可以
> 		可重入
> 	不可以
> 		不可重入锁
>
> 是否可以中断
> 	可以
> 		可中断锁
> 	不可以
> 		非可重入锁
>
> 等待锁的过程
> 	自旋
> 		自旋锁
> 	阻塞
> 		非自旋锁

## 3.乐观锁和悲观锁

1.为什么会诞生非互斥同步锁: 互斥同步锁的劣势

​	◆阻塞和唤醒带来的性能劣势

​	◆永久阻塞:如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将 永远也得不到执行

​	◆优先级反转:disappointed_relieved: 低优先级的拿到了锁，如果一直不释放，那么当等待优先级比较高的想拿的时候却无法拿到

2.什么是乐观锁和悲观锁

乐观锁：

​	◆认为自己在处理操作的时候不会有其他线程来干扰，所以并不会锁住被操作对象

​	◆在更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果没被改变过，就说明真的是只有我自己在操作，那我就正常去修改数据

​	◆如果数据和我开始拿到的不一样了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略

​	◆乐观锁的实现一般都是利用`CAS`算法来实现的

悲观锁：

​	◆如果我不锁住这个资源，别人就会来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失

​	◆Java中悲观锁的实现就是 `synchronized`和`Lock`相关类

3.典型例子

​	◆悲观锁: synchronized和lock接口

​	◆乐观锁的典型例子就是`原子类`、并发容器等

​	◆代码演示

```java
public class PessimismOptimismLock {
    public static void main(String[] args) {
        //乐观锁
        AtomicInteger a = new AtomicInteger();
        a.incrementAndGet();
    }
    //悲观锁
    int a;
    public synchronized void test() {
        a++;
    }

}
```

​	◆Git:Git就是乐观锁的典型例子，当我们往远端仓库push的时候，git会检查远端仓库的版本是不是领先于我们现在的版本，如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远端代码了，我们的这次提交就失败;如果远端和本地版本号一致，我们就可以利提交版本到远端仓库

​	◆数据库

​		◆ select for update就是志观锁

​		◆用 version控制数据库就是乐观锁

4.开销对比

​	◆悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响

​	◆相反，虽然乐观锁—开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多

5.两种锁各自的使用场景

​	◆悲观锁:适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，典型情况

​		1.临界区有IO操作

​		2.临界区代码复杂或者循环量大

​		3.临界区竞争非常激烈

​	◆乐观锁:适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提高。

## 4.可重入锁和非重入锁，以ReentrantLock为例

## 5.公平锁和非公平锁

## 6.共享锁和排它锁：以ReentranReadWriteLock读写锁为例

## 7.自旋锁和阻塞锁

## 8.可中断锁：顾名思义，就是可以响应中断的锁

## 9.锁优化

