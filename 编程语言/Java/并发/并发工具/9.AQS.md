#### 学习AQS的思路

◆学习`AQS`的目的主要是想理解原理、提高技术，以及应对面试

◆先从应用层面理解为什么需要他如何使用它，然后再看一看我们Java代码的设计者是如何使用它的了解它的应用场景

◆这样之后我们再去分析它的结构，这样的话我们就学习得更加轻松了



#### 为什么需要AQS？

◆锁和协作类有共同点:闸门

◆我们已经学过了 `Reentrantlock`和 `Semaphore`，有没有发现它们有共同点？很相似？

◆事实上，不仅是 `ReentrantLock`和 `Semaphore`，包括`CountDownLatch`、 `ReentrantReadWriteLock`都有这样类似的“协作”（或者叫“同步”）功能，其实，它们底层都用了一个共同的基类，这就是`AQS`

**Semaphore和AQS的关系**：

◆ `Semaphore`内部有一个`Sync`类，`Sync`类继承了`AQS`

![image-20211222235751712](https://gitee.com/JKcoding/imgs/raw/master/img/202112222357064.png)

![image-20211223000422638](https://gitee.com/JKcoding/imgs/raw/master/img/202112230004859.png) 

◆ `CountDownLatch`也是一样的，展示代码

就拿招聘作为`AQS`的比喻

◆比喻:群面、单面

◆安排就坐、叫号、先来后到等HR的工作就是`AQS`做的工作

◆面试官不会去关心两个面试者是不是号码相同冲突了，也不想去管面试者需要一个地方坐着休息，这些都交给HR去做

◆ `Semaphore`:一个人面试完了以后，后个人才能进来继续面试

◆ `CountDownLatch`:群面，等待10人到齐

◆ `Semaphore`、 `CountDownLatch`这些同步工具类，要做的，就只是写下自己的“要人”规则。比如是“出一个，进一个或者说“凑齐10人，一起面试”

◆剩下的招呼面试者的脏活累活交给`AQS`来做

**如果没有**`AQS`

◆就需要每个协作工具自己实现

- 同步状态的原子性管理
- 线程的阻塞与解除阻塞
- 队列的管理

◆在并发场景下，自己正确且高效实现这些内容，是相当有难度的，所以我们用`AQS`来帮我们把这些脏活累活都搞定，我们只关注业务逻辑就够了

#### AQS的作用

◆`AQS`是一个用于构建锁、同步器、协作工具类的工具类（框架）。有了`AQS`以后，更多的协作工具类都可以很方便得被写出来

◆一句话总结:有了`AQS`，构建线程协作类就容易多了。



#### AQS的重要性、地位

◆ `AbstractQueuedSynchronizer`是 Doug Lea写的，从JDK1.5加入的一个基于FIFO等待队列实现的一个用于实现同步器的基础框架，我们用IDEA看`AQS`的实现类，可以发现实现类有以下这些:

![image-20211223002541606](https://gitee.com/JKcoding/imgs/raw/master/img/202112230025516.png)

#### AQS内部原理解析

◆`AQS`最核心的就是三大部分

- `state`

  ```java
  /**
   * The synchronization state.
   */
  private volatile int state;
  ```

  ◆这里的 `state`的具体含义，会根据具体实现类的不同而不同，比如在 `Semaphore`里，它表示“剩余的许可证的数量”，而在 `CountDownLatch`里，它表示“还需要倒数的数量

  ◆ `state`是 `volatile`修饰的，会被并发地修改，所以所有修改 `state`的方法都需要保证线程安全，比如 `getState`、 `setState`以及`compareAndSetState`操作来读取和更新这个状态。这些方法都依赖于 `j.u.c.atomic`包的支持

  **state状态**

  ◆在 `ReentrantLock`中

  ◆ state用来表示“锁”的占有情况，包括可重入计数

  ◆当 state的值为0的时候，标识改Lock不被任何线程所占有

- 控制线程抢锁和配合的`FIFO`队列

- 期望协作工具类去实现的获取/释放等重要方法

6.应用实例、源码解析

