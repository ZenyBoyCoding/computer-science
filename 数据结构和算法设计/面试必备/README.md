### 二分法 `Binary Search`

#### **使用条件** 

- 排序数组 (`30-40%`是二分) 
- 当面试官要求你找一个比 `O(n)` 更小的时间复杂度算法的时候(`99%`) 
- 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足(`100%`) 
- 找到一个最大/最小的值使得某个条件被满足(90%)

#### **复杂度** 

- 时间复杂度：`O(logn)` 
- 空间复杂度：`O(1)`

#### **例题**

##### [二分查找](https://www.lintcode.com/problem/14/description?utm_source=sc-cheatsheet-cyc)

给定一个排序的整数数组（升序）和一个要查找的整数 `target`，用O(logn)*O*(*l**o**g**n*)的时间查找到`target`第一次出现的下标（从`0`开始），如果`target`不存在于数组中，返回`-1`。

**样例 1：**

输入：

```
数组 = [1,4,4,5,7,7,8,9,9,10]
target = 1
```

输出：

```
0
```

解释：第一次出现在第0个位置。

**样例 2：**

输入：

```
数组 = [1, 2, 3, 3, 4, 5, 10]
target = 3
```

输出：

```
2
```

解释：第一次出现在第2个位置

**样例 3：**

输入：

```
数组 = [1, 2, 3, 3, 4, 5, 10]
target = 6
```

输出：

```
-1
```

解释：没有出现过6， 返回-1

如果数组中的整数个数超过了2^32，你的算法是否会出错？

---

```java
 public int binarySearch(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
           return -1;
        }
        int low = 0, high = nums.length - 1;
        while (low < high) {
           int mid = low + ((high - low) >> 1);
           if (nums[mid] >= target) {
                high = mid;
           } else {
               //low不断往目标逼近
               low = mid + 1;
           }
        }
        return nums[low] == target ? low : -1;
    }
```

---





##### [在排序数组中找最接近的K个数](https://www.lintcode.com/problem/460/?utm_source=sc-cheatsheet-cyc)

给一个目标数 `target`, 一个非负整数 `k`, 一个按照升序排列的数组 `A`。在`A`中找与`target`最接近的`k`个整数。返回这`k`个数并按照与`target`的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面。

`k`是一个非负整数，并且总是小于已排序数组的长度。给定数组的长度是正整数, 不会超过 10^4104数组中元素的绝对值不会超过 10^4

样例

**样例 1:**

```
输入: A = [1, 2, 3], target = 2, k = 3
输出: [2, 1, 3]
```

**样例 2:**

```
输入: A = [1, 4, 6, 8], target = 3, k = 3
输出: [4, 1, 6]
```

挑战

`O(logn + k)` 的时间复杂度

---





---

##### [书籍复印](https://www.lintcode.com/problem/437/?utm_source=sc-cheatsheet-cyc)

给定`n`本书，第`i`本书有`[i]页`。有`k`个人来抄这些书。

这些书排成一行，每个人都可以索取连续一段的书。例如，一个复印机可以连续地将书从第`i`册复制到第`j`册，但是他不能复制第1册、第2册和第4册（没有第3册）。

他们在同一时间开始抄书，每抄一页书都要花1分钟。为了让最慢的复印机能在最早的时间完成书的分配，最好的策略是什么？请返回最慢复印机花费的最短时间。

书籍页数总和小于等于`2147483647`

样例

**样例 1:**

```
输入: pages = [3, 2, 4], k = 2
输出: 5
解释: 第一个人复印前两本书, 耗时 5 分钟. 第二个人复印第三本书, 耗时 4 分钟.
```

**样例 2:**

```
输入: pages = [3, 2, 4], k = 3
输出: 4
解释: 三个人各复印一本书.
```

挑战：时间复杂度 `O(nk)`

---





---



### 双指针 `Two Pointers`

#### **使用条件** 

- 滑动窗口 `(90%)` 
- 时间复杂度要求 `O(n)` (80%是双指针) 
- 要求原地操作，只可以使用交换，不能使用额外空间 `(80%)` 
- 有子数组 `subarray` /子字符串 `substring` 的关键词 `(50%)` 
- 有回文 `Palindrome` 关键词`(50%)`

#### **复杂度**

1. 时间复杂度：`O(n)` 

-  时间复杂度与最内层循环主体的执行次数有关 
- 与有多少重循环无关 

2. 空间复杂度：`O(1)` 

- 只需要分配两个指针的额外内存

#### 例题

##### 1、两数之和 VII(同向双指针) 

##### 2、和相同的二元子数组(相向双指针) 

##### 3、最长回文串 (背向双指针) 

##### 4、合并有序数组



### 排序算法 `Sorting`

#### **复杂度**

1.  时间复杂度： 

- 快速排序(期望复杂度) ： `O(nlogn)` 
- 归并排序(最坏复杂度) ： `O(nlogn)` 

2. 空间复杂度： 

- 快速排序 ： `O(1)` 
- 归并排序 ： `O(n)` 

#### 例题

##### 1、 整数排序 II



### 二叉树分治 `Binary Tree Divide & Conquer`

#### **使用条件**

- 二叉树相关的问题 `(99%)` 
- 可以一分为二去分别处理之后再合并结果 `(100%)` 
- 数组相关的问题 `(10%)`

#### **复杂度**

- 时间复杂度 `O(n)` 
- 空间复杂度 `O(n)` (含递归调用的栈空间最大耗费)

#### 例题

##### 1、将二叉搜索树转换为已排序的双向链接列表 

##### 2、二叉树中的最大路径和 

##### 3、验证二叉查找树



### 二叉搜索树非递归 `BST Iterator`

#### **使用条件** 

- 用非递归的方式`（Non-recursion / Iteration）`实现二叉树的中序遍历 
- 常用于 `BST` 但不仅仅可以用于 `BST`

#### **复杂度** 

- 时间复杂度 O(n) 
- 空间复杂度 O(n)

#### 例题

##### 1、二叉树的中序遍历 

##### 2、二叉搜索树的第 k 大元素



### 广度优先遍历 `BFS`

#### **使用条件** 

- 拓扑排序`(100%)` 
- 出现连通块的关键词`(100%)` 
- 分层遍历`(100%)` 
- 简单图最短路径`(100%)` 
- 给定一个变换规则，从初始状态变到终止状态最少几步`(100%)`

#### **复杂度**

1.  时间复杂度：`O(n + m)` 

- n 是点数, m 是边数 

2. 空间复杂度：`O(n)`

#### 例题

##### 1、01 矩阵(分层遍历) 

##### 2、找无向图的连通块 

##### 3、拓扑排序 



### 深度优先遍历 `DFS`

#### **使用条件** 

- 找满足某个条件的所有方案 `(99%)` 
- 二叉树 `Binary Tree` 的问题 `(90%)` 
- 组合问题`(95%)` 

​		￮ 问题模型：求出所有满足条件的“组合” 

​		￮ 判断条件：组合中的元素是顺序无关的 

- 排列问题 `(95%)` 

​		￮ 问题模型：求出所有满足条件的“排列” 

​		￮ 判断条件：组合中的元素是顺序“相关”的。 

#### **不要用 DFS 的场景** 

- 连通块问题（一定要用 `BFS`，否则 `StackOverflow`） 
- 拓扑排序（一定要用 `BFS`，否则 `StackOverflow`） 
- 一切 `BFS` 可以解决的问题

#### **复杂度**

-  时间复杂度：O(方案个数 * 构造每个方案的时间) 

​	￮ 树的遍历 ： `O(n)` 

​	￮ 排列问题 ： `O(n! * n)` 

​	￮ 组合问题 ： `O(2^n * n)` 

#### 例题

##### 1、二叉树的中序遍历(遍历树) 

##### 2、因式分解(枚举所有情况)



### 动态规划 `Dynamic Programming`

#### **使用场景** 

- 求方案总数`(90%)` 
- 求最值`(80%)` 
- 求可行性`(80%)`

#### 不适用的场景

- 找所有具体的方案（准确率 `99%`） 
- 输入数据无序(除了背包问题外，准确率 `60%~70%`) 
- 暴力算法已经是多项式时间复杂度（准确率 `80%`） 

#### 动态规划四要素(对比递归的四要素) 

- 状态 (`State`) -- 递归的定义 
- 方程 (`Function`) -- 递归的拆解 
- 初始化 (`Initialization`) -- 递归的出口 
- 答案 (`Answer`) -- 递归的调用 



### 堆 `Heap`

### 并查集 `Union Find`

### 字典树 `Trie`

### `LRU`缓存