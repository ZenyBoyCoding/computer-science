### 二分法 `Binary Search`

#### **使用条件** 

- 排序数组 (`30-40%`是二分) 
- 当面试官要求你找一个比 `O(n)` 更小的时间复杂度算法的时候(`99%`) 
- 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足(`100%`) 
- 找到一个最大/最小的值使得某个条件被满足(90%)

#### **复杂度** 

- 时间复杂度：`O(logn)` 
- 空间复杂度：`O(1)`

#### **例题**

##### 1、[二分查找](https://www.lintcode.com/problem/14/description?utm_source=sc-cheatsheet-cyc)

给定一个排序的整数数组（升序）和一个要查找的整数 `target`，用O(logn)*O*(*l**o**g**n*)的时间查找到`target`第一次出现的下标（从`0`开始），如果`target`不存在于数组中，返回`-1`。

**样例 1：**

输入：

```
数组 = [1,4,4,5,7,7,8,9,9,10]
target = 1
```

输出：

```
0
```

解释：第一次出现在第0个位置。

**样例 2：**

输入：

```
数组 = [1, 2, 3, 3, 4, 5, 10]
target = 3
```

输出：

```
2
```

解释：第一次出现在第2个位置

**样例 3：**

输入：

```
数组 = [1, 2, 3, 3, 4, 5, 10]
target = 6
```

输出：

```
-1
```

解释：没有出现过6， 返回-1

如果数组中的整数个数超过了2^32，你的算法是否会出错？

---

```java
 public int binarySearch(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
           return -1;
        }
        int low = 0, high = nums.length - 1;
        while (low < high) {
           int mid = low + ((high - low) >> 1);
           if (nums[mid] >= target) {
                high = mid;
           } else {
               //low不断往目标逼近
               low = mid + 1;
           }
        }
        return nums[low] == target ? low : -1;
    }
```

---





##### 2、[在排序数组中找最接近的K个数](https://www.lintcode.com/problem/460/?utm_source=sc-cheatsheet-cyc)

给一个目标数 `target`, 一个非负整数 `k`, 一个按照升序排列的数组 `A`。在`A`中找与`target`最接近的`k`个整数。返回这`k`个数并按照与`target`的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面。

`k`是一个非负整数，并且总是小于已排序数组的长度。给定数组的长度是正整数, 不会超过 10^4104数组中元素的绝对值不会超过 10^4

样例

**样例 1:**

```
输入: A = [1, 2, 3], target = 2, k = 3
输出: [2, 1, 3]
```

**样例 2:**

```
输入: A = [1, 4, 6, 8], target = 3, k = 3
输出: [4, 1, 6]
```

挑战

`O(logn + k)` 的时间复杂度

---





---

##### 3、[书籍复印](https://www.lintcode.com/problem/437/?utm_source=sc-cheatsheet-cyc)

给定`n`本书，第`i`本书有`[i]页`。有`k`个人来抄这些书。

这些书排成一行，每个人都可以索取连续一段的书。例如，一个复印机可以连续地将书从第`i`册复制到第`j`册，但是他不能复制第1册、第2册和第4册（没有第3册）。

他们在同一时间开始抄书，每抄一页书都要花1分钟。为了让最慢的复印机能在最早的时间完成书的分配，最好的策略是什么？请返回最慢复印机花费的最短时间。

书籍页数总和小于等于`2147483647`

样例

**样例 1:**

```
输入: pages = [3, 2, 4], k = 2
输出: 5
解释: 第一个人复印前两本书, 耗时 5 分钟. 第二个人复印第三本书, 耗时 4 分钟.
```

**样例 2:**

```
输入: pages = [3, 2, 4], k = 3
输出: 4
解释: 三个人各复印一本书.
```

挑战：时间复杂度 `O(nk)`

---





---



### 双指针 `Two Pointers`

#### **使用条件** 

- 滑动窗口 `(90%)` 
- 时间复杂度要求 `O(n)` (80%是双指针) 
- 要求原地操作，只可以使用交换，不能使用额外空间 `(80%)` 
- 有子数组 `subarray` /子字符串 `substring` 的关键词 `(50%)` 
- 有回文 `Palindrome` 关键词`(50%)`

#### **复杂度**

1. 时间复杂度：`O(n)` 

-  时间复杂度与最内层循环主体的执行次数有关 
- 与有多少重循环无关 

2. 空间复杂度：`O(1)` 

- 只需要分配两个指针的额外内存

#### 例题

##### 1、两数之和 VII(同向双指针) 

##### 2、和相同的二元子数组(相向双指针) 

##### 3、最长回文串 (背向双指针) 

##### 4、合并有序数组



### 排序算法 `Sorting`

#### **复杂度**

1.  时间复杂度： 

- 快速排序(期望复杂度) ： `O(nlogn)` 
- 归并排序(最坏复杂度) ： `O(nlogn)` 

2. 空间复杂度： 

- 快速排序 ： `O(1)` 
- 归并排序 ： `O(n)` 

#### 例题

##### 1、 整数排序 II



### 二叉树分治 `Binary Tree Divide & Conquer`

#### **使用条件**

- 二叉树相关的问题 `(99%)` 
- 可以一分为二去分别处理之后再合并结果 `(100%)` 
- 数组相关的问题 `(10%)`

#### **复杂度**

- 时间复杂度 `O(n)` 
- 空间复杂度 `O(n)` (含递归调用的栈空间最大耗费)

#### 例题

##### 1、将二叉搜索树转换为已排序的双向链接列表 

##### 2、二叉树中的最大路径和 

##### 3、验证二叉查找树



### 二叉搜索树非递归 `BST Iterator`

#### **使用条件** 

- 用非递归的方式`（Non-recursion / Iteration）`实现二叉树的中序遍历 
- 常用于 `BST` 但不仅仅可以用于 `BST`

#### **复杂度** 

- 时间复杂度 `O(n)` 
- 空间复杂度 `O(n)`

#### 例题

##### 1、二叉树的中序遍历 

##### 2、二叉搜索树的第 k 大元素



### 广度优先遍历 `BFS`

#### **使用条件** 

- 拓扑排序`(100%)` 
- 出现连通块的关键词`(100%)` 
- 分层遍历`(100%)` 
- 简单图最短路径`(100%)` 
- 给定一个变换规则，从初始状态变到终止状态最少几步`(100%)`

#### **复杂度**

1.  时间复杂度：`O(n + m)` 

- n 是点数, m 是边数 

2. 空间复杂度：`O(n)`

#### 例题

##### 1、01 矩阵(分层遍历) 

##### 2、找无向图的连通块 

##### 3、拓扑排序 



### 深度优先遍历 `DFS`

#### **使用条件** 

- 找满足某个条件的所有方案 `(99%)` 
- 二叉树 `Binary Tree` 的问题 `(90%)` 
- 组合问题`(95%)` 

​		￮ 问题模型：求出所有满足条件的“组合” 

​		￮ 判断条件：组合中的元素是顺序无关的 

- 排列问题 `(95%)` 

​		￮ 问题模型：求出所有满足条件的“排列” 

​		￮ 判断条件：组合中的元素是顺序“相关”的。 

#### **不要用 DFS 的场景** 

- 连通块问题（一定要用 `BFS`，否则 `StackOverflow`） 
- 拓扑排序（一定要用 `BFS`，否则 `StackOverflow`） 
- 一切 `BFS` 可以解决的问题

#### **复杂度**

-  时间复杂度：O(方案个数 * 构造每个方案的时间) 

​	￮ 树的遍历 ： `O(n)` 

​	￮ 排列问题 ： `O(n! * n)` 

​	￮ 组合问题 ： `O(2^n * n)` 

#### 例题

##### 1、二叉树的中序遍历(遍历树) 

##### 2、因式分解(枚举所有情况)



### 动态规划 `Dynamic Programming`

#### **使用场景** 

- 求方案总数`(90%)` 
- 求最值`(80%)` 
- 求可行性`(80%)`

#### 不适用的场景

- 找所有具体的方案（准确率 `99%`） 
- 输入数据无序(除了背包问题外，准确率 `60%~70%`) 
- 暴力算法已经是多项式时间复杂度（准确率 `80%`） 

#### 动态规划四要素(对比递归的四要素) 

- 状态 (`State`) -- 递归的定义 
- 方程 (`Function`) -- 递归的拆解 
- 初始化 (`Initialization`) -- 递归的出口 
- 答案 (`Answer`) -- 递归的调用 

#### 几种常见的动态规划

##### 背包型  

- 给出 n 个物品及其大小,问是否能挑选出一些物品装满大小为 m 的背包
- 题目中通常有“和”与“差”的概念， 数值会被放到状态中
- 通常是二维的状态数组， 前 i 个组成和为 j 状态数组的大小需要开 `(n + 1) * (m + 1)`
- 几种背包类型：

  1. 01 背包

     状态 `state` :`dp[i] [j]` 表示前 i 个数里挑若干个数是否能组成和为 j   

     方程 `function` ：

     ```java
     dp[i][j] = dp[i - 1][j] or dp[i - 1][j - A[i - 1]] 如果 j >= A[i - 1]
     dp[i][j] = dp[i - 1][j] 如果 j < A[i - 1]
     第 i 个数的下标是 i - 1， 所以用的是 A[i - 1] 而不是 A[i]
     ```

     初始化 `initialization` ：

     ```java
     dp[0][0] = true
     dp[0][1...m] = false
     ```

     答案 `answer`：使得 `dp[n] [v], 0 s <= v <= m 为 true` 的最大 v  

2. 多重背包

   状态 `state`  ：`dp[i] [j]` 表示前 i 个物品挑出一些放到 j 的背包里的最大价值和  

   方程 `function`  ：

   ```java
   dp[i][j] = max(dp[i - 1][j - count * A[i - 1]] + count * V[i - 1])
   其中 0 <= count <= j / A[i - 1]
   ```

   初始化 `initialization`  ：

   ```java
   dp[0][0..m] = 0
   ```

   答案 `answer`  ：`dp[n] [m]`  

   

##### 区间型  

题目中有 `subarray / substring` 的信息
￮ 大区间依赖小区间
￮ 用 `dp[i] [j]` 表示数组/字符串中 i, j 这一段区间的最优值/可行性/方案总数  

 状态 `state`：  `dp[i] [j]` 表示数组/字符串中 i,j 这一段区间的最优值/可行性/方案总数  

 方程 `function`：  `dp[i] [j] = max/min/sum/or(dp[i,j 之内更小的若干区间])`  

##### 匹配型  

￮ 通常给出两个字符串
￮ 两个字符串的匹配值依赖于两个字符串前缀的匹配值
￮ 字符串长度为 n,m 则需要开 `(n + 1) x (m + 1)` 的状态数组
￮ 要初始化 `dp[i] [0]` 与 `dp[0] [i]`
￮ 通常都可以用滚动数组进行空间优化  

​	状态 `state`  ：`dp[i] [j]` 表示第一个字符串的前 i 个字符与第二个字符串的前 j 个字符怎么样怎么样  (max/min/sum/or)    

##### 划分型

￮ 是前缀型动态规划的一种, 有前缀的思想
￮ 如果指定了要划分为几个部分：`dp[i] [j]` 表示前 i 个数/字符划分为 j 个 部分的最优值/方案数/可行性
￮ 如果没有指定划分为几个部分: `dp[i]` 表示前 i 个数/字符划分为若干个 部分的最优值/方案数/可行性  

状态 `state`  :

指定了要划分为几个部分:`dp[i] [j]` 表示前 i 个数/字符划分为 j 个部分的最优值/方案数/可行性
没有指定划分为几个部分: `dp[i]` 表示前 i 个数/字符划分为若干个部分的最优值/方案数/可行性  

##### 接龙型  

￮ 通常会给一个接龙规则， 问你最长的龙有多长
￮ 状态表示通常为: `dp[i]` 表示以坐标为 i 的元素结尾的最长龙的长度
￮ 方程通常是: `dp[i] = max{dp[j] + 1}`, j 的后面可以接上 i
￮ `LIS` 的二分做法选择性的掌握， 但并不是所有的接龙型 DP 都可以用二分来优化  

状态 `state`  : 状态表示通常为: `dp[i]` 表示以坐标为 i 的元素结尾的最长龙的长度  

方程 `function`  ：`dp[i] = max{dp[j] + 1}`, j 的后面可以接上 i  



#### 复杂度  

时间复杂度:
	￮ O(状态总数 * 每个状态的处理耗费)
	￮ 等于 O(状态总数 * 决策数)
空间复杂度：
	￮ O(状态总数) (不使用滚动数组优化)
	￮ O(状态总数 / n)(使用滚动数组优化, n 是被滚动掉的那一个维度)  

#### 例题

##### 1、背包问题 V(背包型)

##### 2、最长上升子序列(接龙型)

##### 3、石子归并 V(区间型)

##### 4、通配符匹配 (匹配型)

##### 5、单词拆分(划分型)  



### 堆 `Heap`

#### 使用条件  

- 找最大值或者最小值`(60%)`
- 找第 k 大(pop k 次 复杂度 `O(nlogk))(50%)`
- 要求 `logn` 时间对数据进行操作(40%)  

#### 堆不能解决的问题  

- 查询比某个数大的最小值/最接近的值（平衡排序二叉树 `Balanced BST` 才可以解决）
- 找某段区间的最大值最小值（线段树 `SegmentTree` 可以解决）
- `O(n)`找第 k 大 (使用快排中的 `partition` 操作)  

#### 例题

##### 1、查找和最小的 K 对数字

##### 2、会议室 II

##### 3、雇佣 K 个人的最低费用  



### 并查集 `Union Find`

#### 使用条件  

- 需要查询图的连通状况的问题
- 需要支持快速合并两个集合的问题  

#### 复杂度  

- 时间复杂度 `union` `O(1)`, `find` `O(1)`
- 空间复杂度 `O(n)`  

#### 例题

##### 1、账号合并

##### 2、打砖块

##### 3、构造二叉树  



### 字典树 `Trie`

#### 使用条件  

- 需要查询包含某个前缀的单词/字符串是否存在
- 字符矩阵中找单词的问题  

#### 复杂度  

- 时间复杂度 `O(L)` 增删查改
- 空间复杂度 `O(N * L)` N 是单词数， L 是单词长度  

#### 例题

##### 1、连接词

##### 2、最大距离

##### 3、映射配对之和  



### `LRU`缓存

#### 复杂度  

- 时间复杂度 `get` `O(1)`, `set` `O(1)`
- 空间复杂度 `O(n)`  

#### 例题

##### 1、 LRU 缓存  