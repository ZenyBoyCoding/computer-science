### 二分法 `Binary Search`

#### **使用条件** 

- 排序数组 (`30-40%`是二分) 
- 当面试官要求你找一个比 `O(n)` 更小的时间复杂度算法的时候(`99%`) 
- 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足(`100%`) 
- 找到一个最大/最小的值使得某个条件被满足(90%)

#### **复杂度** 

- 时间复杂度：`O(logn)` 
- 空间复杂度：`O(1)`

#### **例题**

##### [二分查找](https://www.lintcode.com/problem/14/description?utm_source=sc-cheatsheet-cyc)

给定一个排序的整数数组（升序）和一个要查找的整数 `target`，用O(logn)*O*(*l**o**g**n*)的时间查找到`target`第一次出现的下标（从`0`开始），如果`target`不存在于数组中，返回`-1`。

**样例 1：**

输入：

```
数组 = [1,4,4,5,7,7,8,9,9,10]
target = 1
```

输出：

```
0
```

解释：第一次出现在第0个位置。

**样例 2：**

输入：

```
数组 = [1, 2, 3, 3, 4, 5, 10]
target = 3
```

输出：

```
2
```

解释：第一次出现在第2个位置

**样例 3：**

输入：

```
数组 = [1, 2, 3, 3, 4, 5, 10]
target = 6
```

输出：

```
-1
```

解释：没有出现过6， 返回-1

如果数组中的整数个数超过了2^32，你的算法是否会出错？

---

```java
 public int binarySearch(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
           return -1;
        }
        int low = 0, high = nums.length - 1;
        while (low < high) {
           int mid = low + ((high - low) >> 1);
           if (nums[mid] >= target) {
                high = mid;
           } else {
               //low不断往目标逼近
               low = mid + 1;
           }
        }
        return nums[low] == target ? low : -1;
    }
```

---





##### [在排序数组中找最接近的K个数](https://www.lintcode.com/problem/460/?utm_source=sc-cheatsheet-cyc)

给一个目标数 `target`, 一个非负整数 `k`, 一个按照升序排列的数组 `A`。在`A`中找与`target`最接近的`k`个整数。返回这`k`个数并按照与`target`的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面。

`k`是一个非负整数，并且总是小于已排序数组的长度。给定数组的长度是正整数, 不会超过 10^4104数组中元素的绝对值不会超过 10^4

样例

**样例 1:**

```
输入: A = [1, 2, 3], target = 2, k = 3
输出: [2, 1, 3]
```

**样例 2:**

```
输入: A = [1, 4, 6, 8], target = 3, k = 3
输出: [4, 1, 6]
```

挑战

`O(logn + k)` 的时间复杂度

---





---

##### [书籍复印](https://www.lintcode.com/problem/437/?utm_source=sc-cheatsheet-cyc)

给定`n`本书，第`i`本书有`[i]页`。有`k`个人来抄这些书。

这些书排成一行，每个人都可以索取连续一段的书。例如，一个复印机可以连续地将书从第`i`册复制到第`j`册，但是他不能复制第1册、第2册和第4册（没有第3册）。

他们在同一时间开始抄书，每抄一页书都要花1分钟。为了让最慢的复印机能在最早的时间完成书的分配，最好的策略是什么？请返回最慢复印机花费的最短时间。

书籍页数总和小于等于`2147483647`

样例

**样例 1:**

```
输入: pages = [3, 2, 4], k = 2
输出: 5
解释: 第一个人复印前两本书, 耗时 5 分钟. 第二个人复印第三本书, 耗时 4 分钟.
```

**样例 2:**

```
输入: pages = [3, 2, 4], k = 3
输出: 4
解释: 三个人各复印一本书.
```

挑战：时间复杂度 `O(nk)`

---





---



### 双指针 `Two Pointers`

### 排序算法 `Sorting`

### 二叉树分治 `Binary Tree Divide & Conquer`

### 二叉搜索树非递归 `BST Iterator`

### 广度优先遍历 `BFS`

### 深度优先遍历 `DFS`

### 动态规划 `Dynamic Programming`

### 堆 `Heap`

### 并查集 `Union Find`

### 字典树 `Trie`

### `LRU`缓存