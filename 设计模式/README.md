

#### 为什么要学习设计模式

- 公司项目需要重构，但是不知道如何下手，做到高內聚低耦合
- 为了装下武林高手，面试应对面试官的各种刁难（看招聘要求）
- 为了写些高大上的代码，让新手看不懂。或者为了看懂高手写的代码
- 为了提升自己内力，更好的理解框架源码设计思想，封装中间件
- 让代码更好重用、可读、可靠、可维护、可拓展

#### 学前基础

- 掌握`java/ python/js/c/c++/go`其中一门语言
- 课程基于`java`语言实现，重点是掌握其思想，语言只是实现工具

#### 适合人群

- 中高级客户端、前端、后端工程师、项目经理、`CTO`必备知识
- 从传统软件公司过渡到互联网公司的人员
- 只要是软件开发人员，都建议学这个课程，提升内力

#### 学后水平

- 掌握软件设计的六大原则
- 掌握**创建型模式**：**工厂模式**、**抽象工厂模式**、**单例模式**、**建造者模式**、**原型模式**
- 掌握**结构型模式**：**适配器模式**、**桥接模式**、**装饰器模式**、**代理模式**、**组合模式**、**外观模式**、**享元模式**
- 掌握**行为型模式**：**责任链模式**、**迭代器模式**、**观察者模式**、**状态模式**、**策略模式**、**模板模式**、**备忘录模式**、**命令模式**等
- 掌握20多种设计模式的应用场景、优点、缺点和需求案例实战
- 掌握多个源码里面设计模式的应用和面试题



#### 设计模式六大设计原则

为了让的代码更好重用性，可读性，可靠性，可维护性诞生出了很多软件设计的原则，这6大设计原则是我们

要掌握的，将六大原则的英文首字母拼在一起就是`SOLID`（稳定的），所以也称之为`SOLID`原则

##### 单一职责原则

- 一个类只负责一个功能领域中的相应职责，就一个类而应该只有一个引起它变化的原因
- 是实现高內聚、低耦合的指导方针
- 解释：

​		■高内聚

​				■尽可能类的每个成员方法只完成一件事（最大限度的聚合）

​				■模块内部的代码，相互之间的联系越强，内聚就越高，模块的独立性就越好

​		■低耦合:减少类内部，一个成员方法调用另一个成员方法，不要有牵一发动全身

##### 开闭原则

对扩展开放，对修改关闭，在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果

##### 里氏替换原则`LSP`

- 任何基类可以出现的地方，子类一定可以出现
- 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象
- `controller->service->dao`

##### 依赖倒转原则

- 是开闭原则的基础，针对接口编程，依赖于抽象而不依赖于具体
- 高层模块不应该依赖低层模块，二者都应该依赖其抽象

##### 接口隔离原则

- 客户端不应该依赖那些它不需要的接口
- 使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度

##### 迪米特法则

- 最少知道原则，一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立
- 类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及
- 通过引入一个合理的第三者来降低现有对象之间的耦合度



#### 设计模式到底是什么

**设计模式简介**：

- 由来:是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的
- 好处:为了重用代码、让代码更容易被他人理解、保证代码可靠性
- 坏处:对不熟悉设计模式的同学，看起来更绕更难理解

**什么是GOF(Gang of Four)**

在1994年，由四位作者合称GOF（全拼 Gang of Four四人合著出版了一本名为 Design Patterns- Elements

of Reusable object- Oriented software。他们所提出的设计模式主要是基于以下的面向对象设计原则。

1. 对接口编程而不是对实现编程。
2. 优先使用对象组合而不是继承

#### 常见的三大设计模式分类

##### 创建型模式

​	**概念**：提供了一种在创建对象的同时隐藏创建逻辑的方式，使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活

​	**常用**：工厂模式、抽象工厂模式、单例模式、建造者模式

​	**不常用**: 原型模式

##### 结构型模式

​	**概念**：关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式

​	**常用**∶ 适配器模式、桥接模式、装饰器模式、代理模式

​	**不常用**: 组合模式、外观模式、享元模式

##### 行为型模式

​	**概念**：特别关注对象之间的通信

​	**常用**: 责任链模式、迭代器模式、观察者模式、状态模式、策略模式、模板模式

​	**不常用**: 备忘录模式、命令模式

​	**几乎不用**: 访问者模式、中介者模式、解释器模式



#### 单例设计模式

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法(静态方法)。

**使用场景**：

- 比如`Hibernate`的`SessionFactory`，它充当数据存储源的代理，并负责创建`Session`对象。`SessionFactory`并不是轻量级的，一般情况下，一个项目通常只需要一个`SessionFactory`就够，这是就会使用到单例模式。
- 业务系统全局只需要一个对象实例，比如发号器`redis`连接对象等
- `SpringIOC`容器中的`bean`默认就是单例
- `springboot`中的`controller`、`service`、`dao`层中通过`＠autowire`的依赖注入对象默认都是单例的

**分类**：

- 懒汉:  就是所谓的懒加载，延迟创建对象
- 饿汉:  与懒汉相反，提前创建对象

**八种实现方式**：

1. 饿汉式(静态常量)

   **步骤如下**：

   1) 构造器私有化 (防止 new )

   2) 类的内部创建对象

   3) 向外暴露一个静态的公共方法。`getInstance`

   4) 代码实现

   **代码实现**：

   ```java
   public class SingleTon01 {
       
       private SingleTon01(){}
       
       private static SingleTon01 instance = new SingleTon01();
       
       public static SingleTon01 getInstance() {
           return instance;
       }
   }
   ```

   **优缺点**：

   1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。

   2) 缺点：在类装载的时候就完成实例化，没有达到`LazyLoading`的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费

   3) 这种方式基于`classloder`机制避免了多线程的同步问题，不过，`instance`在类装载时就实例化，在单例模式中大多数都是调用`getInstance`方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化`instance`就没有达到`lazyloading`的效果

   4) 结论：这种单例模式**可用**，**可能**造成内存浪费

      

2. 饿汉式（静态代码块）

   **代码实现**：

   ```java
   public class SingleTon01 {
   
       private SingleTon01(){}
   
       private static SingleTon01 instance;
       static {
           instance = new SingleTon01();
       }
   
       public static SingleTon01 getInstance() {
           return instance;
       }
   }
   ```

   **优缺点说明**：

   1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。

   2) 结论：这种单例模式可用，但是可能造成内存浪费

   

3. 懒汉式(线程不安全)

   **代码实现**：

   ```java
   public class SingleTon01 {
   
       private SingleTon01(){}
   
       private static SingleTon01 instance;
   
       public static SingleTon01 getInstance() {
           if (instance == null) {
               instance = new SingleTon01();
           }
           return instance;
       }
   }
   ```

   **优缺点说明**：

   1) 起到了Lazy Loading的效果，但是只能在单线程下使用。

   2) 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式

   3) 结论：在实际开发中，不要使用这种方式.

   

4. 懒汉式(线程安全，同步方法)

5.  懒汉式(线程安全，同步代码块)

6. 双重检查

7. 静态内部类

8. 枚举

